<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OCR J277 Paper 1</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inter">
</head>
<body>
    <nav class="navbar">
        <a href="/">arthuwu</a>
        <div class="dropdown">
            <a class="dropdown" href="/computersci.html">Computer Science</a>
            <div class="dropdown-content">
                <a href="/paperone.html">Paper 1 (Computer Systems)</a>
            </div>
        </div>
    </nav>
    <div class="flex-container-double content">
        <div class="kontent">  
            <!-- start pasting here and don't spend 30 minutes debugging like past you -->
            <h1 id="system-architecture">1.1 - System Architecture</h1>
            <blockquote>
            <p>Things that are outdated, extra or just incorrect “GCSEisms” will be included in these blockquotes</p>
            </blockquote>
            <h2 id="architecture-of-the-cpu">1.1.1 Architecture of the CPU</h2>
            <p>The <strong>purpose</strong> of the Central Processing Unit (CPU) is</p>
            <ul>
            <li>to processss <strong>data</strong></li>
            <li>to carry out <strong>instructions</strong></li>
            </ul>
            <h3 id="von-neumann-architecture"><strong>Von-Neumann Architecture</strong></h3>
            <blockquote>
            <p>In GCSE, you do not need to know about other CPU architecures.</p>
            </blockquote>
            <ul>
            <li>Both <strong>instructions and data are stored in the same memory</strong></li>
            </ul>
            <blockquote>
            <p>In contrast, the Harvard architecure uses seperate memory for instructions and data</p>
            </blockquote>
            <p>There are several different components in a CPU, including <strong>Registers</strong>, the <strong>Arithmetic Logic Unit (ALU)</strong>, the <strong>Control Unit (CU)</strong>, <strong>buses</strong> and <strong>cache</strong>.</p>
            <blockquote>
            <p>There are several more things in modern microarchitechures, e.g. seperate floating point and interger logic, schedulers, sequencers, queues etc.</p>
            </blockquote>
            <ul>
            <li><strong>Registers</strong> are <strong>high-speed, low-capacity</strong> storage locations, which can be special or general purpose.
            <ul>
            <li><strong>Memory Address Register (MAR)</strong>
            <ul>
            <li>This is where the <strong>address</strong> of the data/instruction <strong>being fetched</strong> is temporarily stored</li>
            <li>This is passed to the RAM via the <strong>address bus</strong></li>
            </ul>
            </li>
            <li><strong>Memory Data Register (MDR)</strong>
            <ul>
            <li>Where the data/instruction <strong>fetched</strong> from the RAM is temporaily stored</li>
            <li><strong>Data</strong> travels <strong>bi-directionally</strong> via the <strong>data bus</strong></li>
            <li><strong>Instructions</strong> only travel <strong>away</strong> from the RAM via the data bus</li>
            <li>
            <blockquote>
            <p>also known as the Memory Buffer Register</p>
            </blockquote>
            </li>
            </ul>
            </li>
            <li><strong>Program Counter (PC)</strong>
            <ul>
            <li>Where the <strong>address of the next data/instruction to be fetched</strong> is held</li>
            </ul>
            </li>
            <li><strong>Accumulator (ACC)</strong>
            <ul>
            <li>Where the <strong>results of calculations</strong> from the ALU are stored</li>
            </ul>
            </li>
            <li><strong>Current Instruction Register (CIR)</strong>
            <ul>
            <li>Splits the instruction received from RAM into:
            <ul>
            <li><strong>opcode</strong>: instructions</li>
            <li><strong>operand</strong>: data</li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </li>
            <li>The <strong>Arithmetic Logic Unit (ALU)</strong> performs <strong>arithmetic</strong> (e.g. +, -, *, /, %, ^) and <strong>logical</strong> operations (AND, OR, NOT)</li>
            </ul>
            <blockquote>
            <p>Fun fact: some basic ARM CPUs cannot do division - they only estimate the answers</p>
            </blockquote>
            <ul>
            <li>The <strong>Control Unit (CU)</strong> “directs” the operations of the CPU. It
            <ul>
            <li><strong>decodes</strong> instructions</li>
            <li>manages the <strong>flow of data</strong> within the CPU and between the CPU and other devices</li>
            <li>accepts the next instruction</li>
            <li>contains the <strong>clock</strong>, which is responsible for timing the FDE cycle</li>
            </ul>
            </li>
            <li><strong>Buses</strong> are “wires” which connect two or more components inside the CPU.
            <ul>
            <li><strong>Data</strong> bus
            <ul>
            <li><strong>Bi-directional</strong></li>
            <li>Used to transport <strong>data and instructions</strong> between the RAM and the <strong>MDR</strong></li>
            </ul>
            </li>
            <li><strong>Address</strong> bus
            <ul>
            <li>From the <strong>CPU to the RAM</strong></li>
            <li>Used to transport the <strong>address to be fetched</strong> from the <strong>MAR</strong></li>
            </ul>
            </li>
            <li><strong>Control</strong> bus
            <ul>
            <li>Bi-directional</li>
            <li>Used to transmit control signals between the CU and other components, e.g.
            <ul>
            <li>Memory read/write</li>
            <li>Clock</li>
            <li>Bus requests</li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </li>
            <li><strong>Cache</strong> is a type of <strong>high-speed</strong> random access memory (RAM) which is <strong>built into</strong> the processor
            <ul>
            <li>Used to <strong>temporarily</strong> hold data and instructions that the <strong>processor is likely to reuse</strong>, to reduce time fetching from RAM</li>
            <li>There are several “levels” of cache; <strong>L1</strong>, <strong>L2</strong> and <strong>L3</strong>:
            <ul>
            <li>In terms of <strong>capacity</strong>, L3 &gt; L2 &gt; L1</li>
            <li>In terms of <strong>speed</strong>/distance to the cores. L1 &gt; L2 &gt; L3</li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            <h3 id="fetch-decode-execute-cycle"><strong>Fetch-Decode-Execute cycle</strong></h3>
            <p>The fetch-decode-execute cycle is the <strong>sequence of operations</strong> that are completed by a processor to <strong>execute</strong> an instruction.</p>
            <ul>
            <li>Fetch phase:
            <ul>
            <li>The address stored in the <strong>program counter (PC)</strong> is <strong>copied</strong> to the <strong>memory address register (MAR)</strong></li>
            <li>The <strong>PC increments by 1</strong></li>
            <li>The <strong>random access memory (RAM)</strong> is instructed to <strong>fetch</strong> the instruction stored in the <strong>address in the MAR</strong> via the <strong>address bus</strong></li>
            <li>The <strong>RAM returns the fetched data</strong> via the <strong>data bus</strong> to the <strong>memory data register (MDR)</strong></li>
            <li>The value in the <strong>MDR</strong> is <strong>copied</strong> to the <strong>current instruction register (CIR)</strong></li>
            </ul>
            </li>
            <li>Decode phase:
            <ul>
            <li>The contents of the <strong>CIR</strong> are <strong>split</strong> into <strong>oprand</strong> (data) and <strong>opcode</strong> (instructions)</li>
            </ul>
            </li>
            <li>Execute phase
            <ul>
            <li>The decoded instruction is sent to the <strong>ALU</strong> and/or the <strong>CU</strong> to be <strong>executed</strong></li>
            <li>The <strong>results</strong> of the ALU are <strong>stored</strong> in the <strong>accumulator</strong></li>
            </ul>
            </li>
            </ul>
            <h2 id="cpu-performance">1.1.2 CPU performance</h2>
            <p>There are several factors impacting CPU performance. These include:</p>
            <ul>
            <li><strong>Clock speed</strong>
            <ul>
            <li>Measured in <strong>hertz (Hz)</strong></li>
            <li>The number of <strong>instructions</strong> (FDE cycles) <strong>which can be carried out in a second</strong></li>
            <li>can be increased by the user by <strong>overclocking</strong></li>
            </ul>
            </li>
            </ul>
            <blockquote>
            <p>Modern CPUs can process multiple instructions in parallel<br>
            There are many ways to overclock which aren’t scary e.g. enabling PBO</p>
            </blockquote>
            <ul>
            <li><strong>Cache size</strong>
            <ul>
            <li>The larger the cache, the more data can be stored on it, the <strong>less time the processor has to wait for instructions to be fetched</strong></li>
            </ul>
            </li>
            <li><strong>Number of cores</strong>
            <ul>
            <li>The more cores a CPU has, the <strong>greater the number of instructions it can process</strong> in a given period of time</li>
            </ul>
            </li>
            </ul>
            <blockquote>
            <p>In modern processors, instruction per clock (IPC) is arguably more important than raw clock speed. Thread count, power efficiency and thermal performace may also be import factors to consider.<br>
            Different microarchitechures also benefit from different factors, e.g. AMD’s Zen line of microarchitechures benefit greately from more/faster cache, while Intel’s recent microarchitechures benefit more from higher clock speed</p>
            </blockquote>
            <h2 id="embedded-systems">1.1.3 Embedded Systems</h2>
            <blockquote>
            <p>why is this in here? idk ask OCR</p>
            </blockquote>
            <p>Embedded systems are <strong>computer systems designed to be built into other electronic devices/appliances to perform a specific function</strong>.<br>
            Its purpose is to:</p>
            <ul>
            <li><strong>Monitor and control</strong> various components in the device</li>
            <li>Allow a user to <strong>interact</strong> with it</li>
            </ul>
            <p>They are usually:</p>
            <ul>
            <li><strong>small</strong> in size</li>
            <li>has <strong>low power consumprion</strong></li>
            <li><strong>low cost</strong></li>
            <li><strong>rugged</strong> operating range</li>
            <li>less processing power</li>
            </ul>
            <p>They are not designed to be programmable easily by a user: they run <strong>firmware</strong>, a piece of software installed on <strong>read-only memory</strong> to control the embedded system</p>
            <p>Examples include:</p>
            <ul>
            <li>GPS systems</li>
            <li>Calculators</li>
            <li>Domestic appliances</li>
            <li>Engine Control Units</li>
            <li>Heating and AC systems</li>
            <li>Factory equipment</li>
            <li>Traffic lights</li>
            <li>etc.</li>
            </ul>
            <blockquote>
            <p>why BIOSes and I/O handling are not included in here i do not know</p>
            </blockquote>
            <h1 id="system-architecture-1">1.2 - System Architecture</h1>
            <h2 id="primary-storage-memory">1.2.1 Primary Storage (Memory)</h2>
            <p>Memory is the component in the computer responsible for <strong>storing data, programs and instructions which are currently in use</strong>.<br>
            It is <strong>used</strong> for data/instructions which are</p>
            <ul>
            <li>currently “in use”, but not being “executed”</li>
            </ul>
            <p>It is <strong>needed</strong> because</p>
            <ul>
            <li>Secondary storage is slow</li>
            </ul>
            <p>It <strong>can</strong>:</p>
            <ul>
            <li>be read from</li>
            <li>be written to (RAM only)</li>
            <li><strong>not</strong> store programs and data when the system is powered off (RAM only)</li>
            </ul>
            <p>There are 2 types of primary memory: <strong>Random Access Memory (RAM)</strong> and <strong>Read-only Memory (ROM)</strong>.</p>
            <h3 id="random-access-memory"><strong>Random Access Memory</strong></h3>
            <ul>
            <li>Used to hold <strong>data and instructions currently in use</strong>
            <ul>
            <li>Programs are copied to the RAM when they are opened, and deleted from it when they are closed</li>
            </ul>
            </li>
            <li><strong>Volatile</strong> - power is required to retain data</li>
            <li>Data can be <strong>accessed from any location</strong> in the memory, i.e <strong>random access</strong></li>
            </ul>
            <blockquote>
            <p>There are 2 main types of RAM: S(tatic)RAM and D(ynamic)RAM. DRAM has to be continuously refreshed while SRAM does not. SRAM is mainly used in cache memory, due to it’s better performance and lower power usage. However, DRAM has higher density which means it is capable of higher capacity</p>
            </blockquote>
            <h3 id="read-only-memory"><strong>Read-only Memory</strong></h3>
            <ul>
            <li>Used to hold <strong>instructions and data a computer requires to run</strong>, for example the <strong>BIOS (Basic Input Output System)</strong> and the <strong>bootstrap</strong>.</li>
            <li><strong>Non-volatile</strong> - power is <strong>not</strong> required to retain data</li>
            <li>Data can only be read from, and not written to</li>
            </ul>
            <blockquote>
            <p>“actual”, hard-wired ROM is rarely used nowadays. Erasable Programmable (EPROM) and Electrically Erasable Programmable (EEPROM) read-only memory, which can be “flashed” to reprogram, are much more common.</p>
            </blockquote>
            <h3 id="virtual-memory"><strong>Virtual Memory</strong></h3>
            <ul>
            <li>Virtual memory is the <strong>use of secondary storage as primary memory</strong></li>
            <li>Used when the amount of RAM needed is greater than the amount of physical RAM available to the computer
            <ul>
            <li>When this occurs, data not currently being used by the CPU is transferred to secondary storage, and data currently being used is transferred to the RAM. This is known as <strong>swapping</strong>.</li>
            <li>As you may expect, this causes the secondary storage to <strong>excessively read and write</strong>, leading to slower acess speeds. This is known as <strong>disk thrashing</strong>.</li>
            </ul>
            </li>
            </ul>
            <h2 id="secondary-storage">1.2.2 Secondary Storage</h2>
            <p><strong>Secondary storage</strong> is <strong>non volatile</strong>, long-term storage.<br>
            It is <strong>used</strong> for data/instructions which are</p>
            <ul>
            <li>not currently in use</li>
            <li>to be stored indefinitely</li>
            </ul>
            <p>It is <strong>needed</strong> because</p>
            <ul>
            <li>RAM is volatile</li>
            <li>ROM is read-only</li>
            </ul>
            <p>It <strong>can</strong>:</p>
            <ul>
            <li>be written to and read from</li>
            <li>store both data and instructions, even when the system is powered off</li>
            </ul>
            <p>There are many forms of secondary storage, each with its own set of characteristics.<br>
            We will mainly focus on:</p>
            <ul>
            <li><strong>Cost</strong>
            <ul>
            <li>How much somebody needs to pay to purchase/operate/maintain the storage medium</li>
            </ul>
            </li>
            <li><strong>Capacity</strong>
            <ul>
            <li>How much data can be stored in the storage medium</li>
            <li>Bit/Byte/KB/MB/GB/TB etc.</li>
            </ul>
            </li>
            <li><strong>Speed of access</strong>
            <ul>
            <li>How fast can the data be accessed in the storage medium</li>
            <li>KB/s, GB/s etc.</li>
            </ul>
            </li>
            <li><strong>Portability</strong>
            <ul>
            <li>How portable is the medium? Is it small and easy to carry?</li>
            </ul>
            </li>
            <li><strong>Durability</strong>
            <ul>
            <li>How durable is the medium? Does it break easily?</li>
            </ul>
            </li>
            <li><strong>Reliability</strong>
            <ul>
            <li>How reliable is the medium? Does it stop working frequently?</li>
            </ul>
            </li>
            </ul>
            <blockquote>
            <p>In your exam, it is important to give most if not all of these factors when comparing 2 storage mediums</p>
            </blockquote>
            <ul>
            <li>Some devices, e.g. <strong>embedded systems</strong> do not need to have data stored in secondary storage to operate.</li>
            </ul>
            <br>
            <table>
            <thead>
            <tr>
            <th>Characteristic</th>
            <th>Magnetic</th>
            <th>Optical</th>
            <th>Solid-state</th>
            </tr>
            </thead>
            <tbody>
            <tr>
            <td>How it works</td>
            <td>A write/read head moves across the surface of a spinning metal “platter”. To write data, it magnetises (1) or demagnetises (0) tiny sections of the platter.</td>
            <td>A laser beam scans the surface of the optical “disk”, which has “tracks” of flat areas (lands) and pits (hollows). If light is reflected (lands), 1 is registered. If no light bounces back (hollows), 0 is registered.</td>
            <td>Electrons are stored in floating gates (usually NAND gates), bound between oxide layers. TRUE returns 1, and FALSE returns 0</td>
            </tr>
            <tr>
            <td>Types</td>
            <td>- <strong>Internal</strong> Hard Disk Drive (HDD) <br> - <strong>External</strong> HDD <br> - Floppy disk</td>
            <td>- Compact Disk (<strong>CD</strong>) - ROM/RW <br> - Digital Video Disk (<strong>DVD</strong>) - ROM/RW <br> - <strong>Blu-ray</strong> - ROM/RW</td>
            <td>- <strong>USB Thumb Drive</strong> <br> - Solid State Drive (<strong>SSD</strong>)</td>
            </tr>
            <tr>
            <td>Cost</td>
            <td>Cheapest</td>
            <td>Cheap</td>
            <td><strong>More expensive</strong></td>
            </tr>
            <tr>
            <td>Capacity</td>
            <td><strong>Largest</strong> (500GB - 12+ TB)</td>
            <td>Small (640MB (CD), 4.7GB (DVD), 50GB (Blu-ray))</td>
            <td>Large (2GB (thumb drives) - 8TB)</td>
            </tr>
            <tr>
            <td>Speed of access</td>
            <td>Slow</td>
            <td>Very slow</td>
            <td><strong>Very fast</strong> <br> - Limited by protocol used to connect to device</td>
            </tr>
            <tr>
            <td>Portability</td>
            <td>Least <br> - Large and heavy</td>
            <td>More <br> - Thin and light <br> - Easy to break</td>
            <td><strong>Most</strong> <br> - Small and light</td>
            </tr>
            <tr>
            <td>Durability</td>
            <td>Resonable</td>
            <td>Poor</td>
            <td><strong>Most</strong></td>
            </tr>
            <tr>
            <td>Reliability</td>
            <td>Good</td>
            <td>Good</td>
            <td>Good</td>
            </tr>
            </tbody>
            </table>
            <!-- stop pasting here and don't spend 30 minutes debugging like past you -->
        </div>
        <div class="table-of-contents flex-right">
            <ul class="fixed-position">
                <li><a class="linkedtext" href="#system-architecture">1.1 - System Architecture</a>
                    <ul>
                    <li><a class="linkedtext" href="#architecture-of-the-cpu">1.1.1 Architecture of the CPU</a></li>
                    <li><a class="linkedtext" href="#cpu-performance">1.1.2 CPU performance</a></li>
                    <li><a class="linkedtext" href="#embedded-systems">1.1.3 Embedded Systems</a></li>
                    </ul>
                </li>
                <li><a class="linkedtext" href="#system-architecture-1">1.2 - System Architecture</a>
                    <ul>
                    <li><a class="linkedtext" href="#primary-storage-memory">1.2.1 Primary Storage (Memory)</a></li>
                    <li><a class="linkedtext" href="#secondary-storage">1.2.2 Secondary Storage</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>
</body>
</html>